# ðŸŽµ MyLabel â†’ 10/10 Roadmap

## ðŸŽ¯ **DA 9.2 A 10/10: IL PIANO DEFINITIVO**

Per trasformare MyLabel in un progetto **perfetto** (10/10), ecco cosa implementare in ordine di prioritÃ :

---

## ðŸ§ª **1. TEST SUITE COMPLETA (CRITICO)**

### Testing Strategy Professionale
```python
# tests/test_booking_system.py
class BookingSystemTestCase(TestCase):
    def setUp(self):
        self.artist_user = User.objects.create_user('artist_test', 'test@test.com', 'pass')
        self.associate_user = User.objects.create_user('associate_test', 'test2@test.com', 'pass')
        
        Profile.objects.create(user=self.artist_user, user_type='artist')
        Profile.objects.create(user=self.associate_user, user_type='associate')
        
        self.artist = Artist.objects.create(
            user=self.artist_user, 
            stage_name='Test Artist',
            genres='Rock, Pop'
        )
        self.associate = Associate.objects.create(
            user=self.associate_user,
            specialization='Sound Engineer',
            hourly_rate=50.00
        )
    
    def test_booking_conflict_prevention(self):
        """Test prevenzione conflitti orari"""
        session_time = timezone.now() + timedelta(days=1)
        
        # Prima prenotazione
        booking1 = Booking.objects.create(
            artist=self.artist,
            associate=self.associate,
            session_date=session_time,
            duration_hours=2,
            status='confirmed'
        )
        
        # Seconda prenotazione sovrapposta dovrebbe fallire
        booking2 = Booking(
            artist=self.artist,
            associate=self.associate,
            session_date=session_time + timedelta(hours=1),
            duration_hours=2,
            status='pending'
        )
        
        with self.assertRaises(ValidationError):
            booking2.full_clean()
    
    def test_automatic_cost_calculation(self):
        """Test calcolo automatico costo"""
        booking = Booking.objects.create(
            artist=self.artist,
            associate=self.associate,
            session_date=timezone.now() + timedelta(days=1),
            duration_hours=3,
        )
        
        self.assertEqual(booking.total_cost, 150.00)  # 3 * 50â‚¬
    
    def test_booking_workflow_states(self):
        """Test workflow stati booking"""
        booking = Booking.objects.create(
            artist=self.artist,
            associate=self.associate,
            session_date=timezone.now() + timedelta(days=1),
            duration_hours=2,
        )
        
        self.assertEqual(booking.status, 'pending')
        
        booking.status = 'confirmed'
        booking.save()
        
        self.assertTrue(booking.is_upcoming)
        self.assertFalse(booking.can_be_cancelled)  # < 24h

# tests/test_models.py
class ArtistModelTest(TestCase):
    def test_get_genres_list(self):
        artist = Artist(genres='Rock, Pop, Jazz')
        expected = ['Rock', 'Pop', 'Jazz']
        self.assertEqual(artist.get_genres_list(), expected)
    
    def test_get_genres_list_with_spaces(self):
        artist = Artist(genres='Rock ,  Pop,Jazz  ')
        expected = ['Rock', 'Pop', 'Jazz']
        self.assertEqual(artist.get_genres_list(), expected)

# tests/test_views.py
class ArtistViewsTest(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user('test', 'test@test.com', 'pass')
        Profile.objects.create(user=self.user, user_type='artist')
        
    def test_artist_creation_requires_login(self):
        response = self.client.get('/artists/create/')
        self.assertEqual(response.status_code, 302)  # Redirect to login
    
    def test_artist_creation_success(self):
        self.client.login(username='test', password='pass')
        response = self.client.post('/artists/create/', {
            'stage_name': 'Test Artist',
            'genres': 'Rock, Pop',
            'bio': 'Test bio',
            'location': 'Rome',
        })
        self.assertEqual(response.status_code, 302)
        self.assertTrue(Artist.objects.filter(stage_name='Test Artist').exists())
    
    def test_search_functionality(self):
        Artist.objects.create(
            user=self.user,
            stage_name='Rock Star',
            genres='Rock, Metal'
        )
        
        response = self.client.get('/artists/?search=Rock')
        self.assertContains(response, 'Rock Star')

# tests/test_forms.py
class FormValidationTest(TestCase):
    def test_demo_form_valid_url(self):
        form = DemoForm({
            'title': 'Test Demo',
            'external_audio_url': 'https://soundcloud.com/test/demo',
            'genre': 'rock',
            'is_public': True
        })
        self.assertTrue(form.is_valid())
    
    def test_demo_form_invalid_url(self):
        form = DemoForm({
            'title': 'Test Demo',
            'external_audio_url': 'invalid-url',
            'genre': 'rock',
        })
        self.assertFalse(form.is_valid())

# tests/test_integration.py
class BookingIntegrationTest(TestCase):
    """Test end-to-end booking workflow"""
    
    def test_complete_booking_flow(self):
        # Setup users
        artist_user = User.objects.create_user('artist', 'artist@test.com', 'pass')
        associate_user = User.objects.create_user('associate', 'associate@test.com', 'pass')
        
        # Setup profiles
        Profile.objects.create(user=artist_user, user_type='artist')
        Profile.objects.create(user=associate_user, user_type='associate')
        
        # Setup artist/associate
        artist = Artist.objects.create(user=artist_user, stage_name='Test Artist')
        associate = Associate.objects.create(
            user=associate_user, 
            specialization='Producer',
            hourly_rate=40.00
        )
        
        # Test booking creation
        self.client.login(username='artist', password='pass')
        
        session_date = (timezone.now() + timedelta(days=2)).strftime('%Y-%m-%d')
        response = self.client.post(f'/booking/create/{associate.id}/', {
            'session_date': session_date,
            'session_time': '14:00',
            'duration_hours': 3,
            'booking_type': 'recording',
            'location': 'Test Studio',
            'notes': 'Test recording session'
        })
        
        self.assertEqual(response.status_code, 302)
        
        # Verify booking created
        booking = Booking.objects.get(artist=artist, associate=associate)
        self.assertEqual(booking.status, 'pending')
        self.assertEqual(booking.total_cost, 120.00)  # 3 * 40â‚¬
        
        # Test associate confirmation
        self.client.login(username='associate', password='pass')
        response = self.client.post(f'/booking/{booking.id}/update-status/', {
            'status': 'confirmed'
        })
        
        booking.refresh_from_db()
        self.assertEqual(booking.status, 'confirmed')

# Comando per test coverage
# pip install coverage
# coverage run --source='.' manage.py test
# coverage report -m
# coverage html  # Genera report HTML
```

### ðŸŽ¯ **Test Configuration**
```python
# settings/test.py
from .base import *

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:'
    }
}

PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.MD5PasswordHasher',  # Faster for tests
]

EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'

# Disable migrations for faster tests
class DisableMigrations:
    def __contains__(self, item):
        return True
    def __getitem__(self, item):
        return None

MIGRATION_MODULES = DisableMigrations()
```

---

## ðŸ”Œ **2. REST API COMPLETA**

### API Architecture
```python
# api/serializers.py
from rest_framework import serializers
from artists.models import Artist, Demo
from associates.models import Associate, PortfolioItem
from booking.models import Booking

class ArtistListSerializer(serializers.ModelSerializer):
    demos_count = serializers.SerializerMethodField()
    avatar_url = serializers.SerializerMethodField()
    genres_list = serializers.SerializerMethodField()
    
    class Meta:
        model = Artist
        fields = ['id', 'stage_name', 'genres_list', 'location', 'avatar_url', 'demos_count']
    
    def get_demos_count(self, obj):
        return obj.demos.filter(is_public=True).count()
    
    def get_avatar_url(self, obj):
        return obj.user.profile.get_avatar_url()
    
    def get_genres_list(self, obj):
        return obj.get_genres_list()

class ArtistDetailSerializer(ArtistListSerializer):
    demos = serializers.SerializerMethodField()
    social_links = serializers.SerializerMethodField()
    
    class Meta(ArtistListSerializer.Meta):
        fields = ArtistListSerializer.Meta.fields + [
            'bio', 'phone', 'demos', 'social_links', 'created_at'
        ]
    
    def get_demos(self, obj):
        demos = obj.demos.filter(is_public=True)[:5]
        return DemoSerializer(demos, many=True).data
    
    def get_social_links(self, obj):
        return {
            'spotify': obj.spotify_url,
            'youtube': obj.youtube_url,
            'soundcloud': obj.soundcloud_url,
            'instagram': obj.instagram_url,
        }

class DemoSerializer(serializers.ModelSerializer):
    artist_name = serializers.CharField(source='artist.stage_name', read_only=True)
    platform = serializers.SerializerMethodField()
    
    class Meta:
        model = Demo
        fields = ['id', 'title', 'genre', 'description', 'duration', 
                 'external_audio_url', 'platform', 'artist_name', 'uploaded_at']
    
    def get_platform(self, obj):
        return obj.get_platform()

class BookingSerializer(serializers.ModelSerializer):
    artist_name = serializers.CharField(source='artist.stage_name', read_only=True)
    associate_name = serializers.CharField(source='associate.user.get_full_name', read_only=True)
    can_modify = serializers.SerializerMethodField()
    
    class Meta:
        model = Booking
        fields = ['id', 'artist_name', 'associate_name', 'booking_type', 
                 'session_date', 'duration_hours', 'location', 'status', 
                 'total_cost', 'can_modify', 'created_at']
    
    def get_can_modify(self, obj):
        return obj.status == 'pending' and obj.is_upcoming

# api/views.py
from rest_framework import generics, filters, permissions, status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination
from django_filters.rest_framework import DjangoFilterBackend

class StandardResultsSetPagination(PageNumberPagination):
    page_size = 12
    page_size_query_param = 'page_size'
    max_page_size = 100

class ArtistListAPIView(generics.ListAPIView):
    queryset = Artist.objects.filter(is_active=True)
    serializer_class = ArtistListSerializer
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['location']
    search_fields = ['stage_name', 'genres', 'bio']
    ordering_fields = ['stage_name', 'created_at']
    ordering = ['-created_at']

class ArtistDetailAPIView(generics.RetrieveAPIView):
    queryset = Artist.objects.filter(is_active=True)
    serializer_class = ArtistDetailSerializer

class DemoListAPIView(generics.ListAPIView):
    serializer_class = DemoSerializer
    pagination_class = StandardResultsSetPagination
    filter_backends = [DjangoFilterBackend, filters.SearchFilter]
    filterset_fields = ['genre', 'artist']
    search_fields = ['title', 'description']
    
    def get_queryset(self):
        return Demo.objects.filter(is_public=True).select_related('artist')

class MyBookingsAPIView(generics.ListAPIView):
    serializer_class = BookingSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        if hasattr(self.request.user, 'artist'):
            return Booking.objects.filter(artist=self.request.user.artist)
        elif hasattr(self.request.user, 'associate'):
            return Booking.objects.filter(associate=self.request.user.associate)
        return Booking.objects.none()

@api_view(['GET'])
def api_stats(request):
    """API endpoint per statistiche globali"""
    return Response({
        'total_artists': Artist.objects.filter(is_active=True).count(),
        'total_associates': Associate.objects.filter(is_active=True).count(),
        'total_demos': Demo.objects.filter(is_public=True).count(),
        'total_bookings': Booking.objects.count(),
        'recent_artists': ArtistListSerializer(
            Artist.objects.filter(is_active=True).order_by('-created_at')[:5], 
            many=True
        ).data
    })

# api/urls.py
from django.urls import path
from . import views

app_name = 'api'

urlpatterns = [
    # Artists
    path('artists/', views.ArtistListAPIView.as_view(), name='artist-list'),
    path('artists/<int:pk>/', views.ArtistDetailAPIView.as_view(), name='artist-detail'),
    
    # Demos
    path('demos/', views.DemoListAPIView.as_view(), name='demo-list'),
    
    # Bookings
    path('my-bookings/', views.MyBookingsAPIView.as_view(), name='my-bookings'),
    
    # Stats
    path('stats/', views.api_stats, name='stats'),
]
```

### ðŸ“± **API Documentation**
```python
# Aggiungi al requirements.txt:
# djangorestframework>=3.14.0
# django-filter>=23.0
# drf-spectacular>=0.26.0  # Per OpenAPI docs

# settings.py
INSTALLED_APPS += [
    'rest_framework',
    'django_filters',
    'drf_spectacular',
]

REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 12,
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ],
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}

SPECTACULAR_SETTINGS = {
    'TITLE': 'MyLabel API',
    'DESCRIPTION': 'API per gestione etichetta musicale',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
}
```

---

## ðŸ’¬ **3. REAL-TIME MESSAGING CON WEBSOCKETS**

### Django Channels Implementation
```python
# requirements.txt
# channels>=4.0.0
# channels-redis>=4.1.0

# settings.py
INSTALLED_APPS += ['channels']

ASGI_APPLICATION = 'music_label.asgi.application'

CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [os.environ.get('REDIS_URL', 'redis://localhost:6379')],
        },
    },
}

# asgi.py
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
import messaging.routing

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'music_label.settings')

application = ProtocolTypeRouter({
    'http': get_asgi_application(),
    'websocket': AuthMiddlewareStack(
        URLRouter(
            messaging.routing.websocket_urlpatterns
        )
    ),
})

# messaging/consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import User
from .models import Message, Conversation

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.user = self.scope['user']
        if self.user.is_anonymous:
            await self.close()
            return
        
        self.room_name = self.scope['url_route']['kwargs']['room_name']
        self.room_group_name = f'chat_{self.room_name}'
        
        # Join room group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
    
    async def disconnect(self, close_code):
        # Leave room group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        data = json.loads(text_data)
        message_type = data.get('type', 'chat_message')
        
        if message_type == 'chat_message':
            message_content = data['message']
            recipient_id = data['recipient_id']
            
            # Save message to database
            message = await self.save_message(message_content, recipient_id)
            
            # Send message to room group
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'chat_message',
                    'message': message_content,
                    'sender': self.user.username,
                    'sender_id': self.user.id,
                    'timestamp': message.created_at.isoformat(),
                    'message_id': message.id,
                }
            )
        elif message_type == 'typing':
            # Handle typing indicators
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'typing_indicator',
                    'user': self.user.username,
                    'is_typing': data.get('is_typing', False),
                }
            )
    
    async def chat_message(self, event):
        # Send message to WebSocket
        await self.send(text_data=json.dumps({
            'type': 'chat_message',
            'message': event['message'],
            'sender': event['sender'],
            'sender_id': event['sender_id'],
            'timestamp': event['timestamp'],
            'message_id': event['message_id'],
        }))
    
    async def typing_indicator(self, event):
        # Don't send typing indicator back to sender
        if event['user'] != self.user.username:
            await self.send(text_data=json.dumps({
                'type': 'typing',
                'user': event['user'],
                'is_typing': event['is_typing'],
            }))
    
    @database_sync_to_async
    def save_message(self, message_content, recipient_id):
        recipient = User.objects.get(id=recipient_id)
        return Message.objects.create(
            sender=self.user,
            recipient=recipient,
            message=message_content,
            message_type='general'
        )

# messaging/routing.py
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/chat/(?P<room_name>\w+)/$', consumers.ChatConsumer.as_asgi()),
]

# Frontend WebSocket JavaScript
const chatSocket = new WebSocket(
    'ws://' + window.location.host + '/ws/chat/' + roomName + '/'
);

chatSocket.onmessage = function(e) {
    const data = JSON.parse(e.data);
    
    if (data.type === 'chat_message') {
        displayMessage(data);
    } else if (data.type === 'typing') {
        showTypingIndicator(data);
    }
};

function sendMessage(message, recipientId) {
    chatSocket.send(JSON.stringify({
        'type': 'chat_message',
        'message': message,
        'recipient_id': recipientId
    }));
}

function sendTypingIndicator(isTyping) {
    chatSocket.send(JSON.stringify({
        'type': 'typing',
        'is_typing': isTyping
    }));
}
```

---

## ðŸ“Š **4. ADVANCED ANALYTICS & DASHBOARD**

### Analytics Models
```python
# analytics/models.py
class ProfileView(models.Model):
    viewer = models.ForeignKey(User, on_delete=models.CASCADE, related_name='profile_views')
    viewed_profile = models.ForeignKey(User, on_delete=models.CASCADE, related_name='received_views')
    viewed_at = models.DateTimeField(auto_now_add=True)
    ip_address = models.GenericIPAddressField()
    user_agent = models.TextField()

class DemoPlay(models.Model):
    demo = models.ForeignKey('artists.Demo', on_delete=models.CASCADE, related_name='plays')
    listener = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True)
    played_at = models.DateTimeField(auto_now_add=True)
    ip_address = models.GenericIPAddressField()
    duration_seconds = models.PositiveIntegerField(default=0)

class SearchQuery(models.Model):
    query = models.CharField(max_length=200)
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True)
    results_count = models.PositiveIntegerField()
    searched_at = models.DateTimeField(auto_now_add=True)

# dashboard/views.py
@login_required
def analytics_dashboard(request):
    if hasattr(request.user, 'artist'):
        stats = get_artist_analytics(request.user.artist)
    elif hasattr(request.user, 'associate'):
        stats = get_associate_analytics(request.user.associate)
    else:
        stats = {}
    
    return render(request, 'dashboard/analytics.html', {'stats': stats})

def get_artist_analytics(artist):
    from django.db.models import Count, Avg
    from datetime import datetime, timedelta
    
    # Last 30 days
    last_month = timezone.now() - timedelta(days=30)
    
    return {
        'profile_views': ProfileView.objects.filter(
            viewed_profile=artist.user,
            viewed_at__gte=last_month
        ).count(),
        
        'demo_plays': DemoPlay.objects.filter(
            demo__artist=artist,
            played_at__gte=last_month
        ).count(),
        
        'popular_demos': artist.demos.annotate(
            plays_count=Count('plays')
        ).order_by('-plays_count')[:5],
        
        'monthly_views': ProfileView.objects.filter(
            viewed_profile=artist.user,
            viewed_at__gte=last_month
        ).extra({
            'day': "DATE(viewed_at)"
        }).values('day').annotate(
            count=Count('id')
        ).order_by('day'),
        
        'bookings_stats': {
            'total': artist.bookings.count(),
            'pending': artist.bookings.filter(status='pending').count(),
            'confirmed': artist.bookings.filter(status='confirmed').count(),
            'completed': artist.bookings.filter(status='completed').count(),
        }
    }

def get_associate_analytics(associate):
    last_month = timezone.now() - timedelta(days=30)
    
    return {
        'total_earnings': associate.bookings.filter(
            status='completed'
        ).aggregate(
            total=models.Sum('total_cost')
        )['total'] or 0,
        
        'monthly_bookings': associate.bookings.filter(
            created_at__gte=last_month
        ).count(),
        
        'avg_rating': associate.user.reviews_received.aggregate(
            avg=models.Avg('rating')
        )['avg'] or 0,
        
        'popular_services': associate.bookings.values(
            'booking_type'
        ).annotate(
            count=Count('id')
        ).order_by('-count'),
    }
```

---

## ðŸ”’ **5. ADVANCED SECURITY & PERFORMANCE**

### Security Enhancements
```python
# security/middleware.py
import time
from django.core.cache import cache
from django.http import HttpResponseTooManyRequests
from django.conf import settings

class RateLimitMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        if self.is_rate_limited(request):
            return HttpResponseTooManyRequests('Rate limit exceeded')
        
        response = self.get_response(request)
        return response

    def is_rate_limited(self, request):
        if request.user.is_authenticated:
            key = f"rate_limit_user_{request.user.id}"
            limit = 100  # requests per hour for authenticated users
        else:
            key = f"rate_limit_ip_{self.get_client_ip(request)}"
            limit = 20   # requests per hour for anonymous users
        
        current = cache.get(key, 0)
        if current >= limit:
            return True
        
        cache.set(key, current + 1, 3600)  # 1 hour
        return False

    def get_client_ip(self, request):
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            return x_forwarded_for.split(',')[0]
        return request.META.get('REMOTE_ADDR')

# security/decorators.py
from functools import wraps
from django.http import HttpResponseForbidden
from django.contrib.auth.decorators import login_required

def owner_required(model_class, pk_param='pk'):
    def decorator(view_func):
        @wraps(view_func)
        @login_required
        def wrapper(request, *args, **kwargs):
            obj_pk = kwargs.get(pk_param)
            obj = model_class.objects.get(pk=obj_pk)
            
            # Check ownership based on model type
            if hasattr(obj, 'user') and obj.user != request.user:
                return HttpResponseForbidden("You don't own this resource")
            elif hasattr(obj, 'artist') and obj.artist.user != request.user:
                return HttpResponseForbidden("You don't own this resource")
            elif hasattr(obj, 'associate') and obj.associate.user != request.user:
                return HttpResponseForbidden("You don't own this resource")
            
            return view_func(request, *args, **kwargs)
        return wrapper
    return decorator

# Performance optimizations
# models.py additions
class ArtistManager(models.Manager):
    def with_stats(self):
        return self.select_related('user', 'user__profile').prefetch_related('demos')
    
    def popular_artists(self, limit=10):
        return self.with_stats().annotate(
            profile_views_count=Count('user__received_views')
        ).order_by('-profile_views_count')[:limit]

class Artist(models.Model):
    # ... existing fields ...
    objects = ArtistManager()
    
    @property
    def cached_demos_count(self):
        return cache.get_or_set(
            f'artist_{self.id}_demos_count',
            lambda: self.demos.filter(is_public=True).count(),
            3600  # Cache for 1 hour
        )

# Caching strategy
from django.core.cache import cache
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator

@method_decorator(cache_page(60 * 15), name='dispatch')  # 15 minutes
class ArtistListView(ListView):
    model = Artist
    template_name = 'artists/artist_list.html'
    paginate_by = 12
    
    def get_queryset(self):
        return Artist.objects.with_stats().filter(is_active=True)
```

---

## ðŸš€ **6. CI/CD PIPELINE & MONITORING**

### GitHub Actions Workflow
```yaml
# .github/workflows/django.yml
name: Django CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install coverage pytest-django
    
    - name: Run migrations
      run: |
        python manage.py migrate
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb
    
    - name: Run tests with coverage
      run: |
        coverage run --source='.' manage.py test
        coverage report -m
        coverage xml
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
    
    - name: Run linting
      run: |
        pip install flake8 black isort
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        black --check .
        isort --check-only .

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Deploy to Render
      uses: johnbeynon/render-deploy-action@v0.0.8
      with:
        service-id: ${{ secrets.RENDER_SERVICE_ID }}
        api-key: ${{ secrets.RENDER_API_KEY }}
```

### Monitoring & Logging
```python
# monitoring/middleware.py
import time
import logging
from django.db